C({"name": "jQuery.Controller.prototype.bind", "params": {"el": {"description": "<p>The element to be bound.  If an eventName is provided,\nthe controller's element is used instead.</p>", "type": "HTMLElement|jQuery.fn|Object", "optional": true, "order": 0, "name": "el", "default": "this.element"}, "eventName": {"description": "<p>The event to listen for.</p>", "type": "String", "optional": false, "order": 1, "name": "eventName"}, "func": {"description": "<p>A callback function or the String name of a controller function.  If a controller\nfunction name is given, the controller function is called back with the bound element and event as the first\nand second parameter.  Otherwise the function is called back like a normal bind.</p>", "type": "Function|String", "optional": false, "order": 2, "name": "func"}}, "ret": {"description": "<p>The id of the binding in this._bindings</p>", "type": "Integer"}, "type": "function", "parents": ["jQuery.Controller.prototype"], "comment": "<p>Bind attaches event handlers that will be \nremoved when the controller is removed.  </p>\n\n<p>This used to be a good way to listen to events outside the controller's\n[jQuery.Controller.prototype.element element].  However,\nusing templated event listeners is now the prefered way of doing this.</p>\n\n<h3>Example:</h3>\n\n<pre><code>init: function() {\n   // calls somethingClicked(el,ev)\n   this.bind('click','somethingClicked') \n\n   // calls function when the window is clicked\n   this.bind(window, 'click', function(ev){\n     //do something\n   })\n},\nsomethingClicked: function( el, ev ) {\n\n}\n</code></pre>", "src": "../jquery/controller/controller.js", "children": []})